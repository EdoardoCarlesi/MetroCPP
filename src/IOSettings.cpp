#include <string>
#include <sstream>
#include <fstream>

#include <array>
#include <cstdio>
#include <memory>
#include <stdexcept>
#include <stdio.h>
#include <stdlib.h>

#include "IOSettings.h"
#include "general.h"

using namespace std;


IOSettings::IOSettings() 
{
};


IOSettings::~IOSettings() 
{
};


void IOSettings::FindCatID()
{	
	string outputSh;
	string inputSh;
	string optionsSh;
	string outputTmp;
	string lineIn;
	string cleanTmp;
	char *tmpLine;
	int iS = 0;

	optionsSh = pathInput + " " + catFormat;
	outputTmp = thisPath + tmpIdOut;
	inputSh = thisPath + findIDsh + " " + optionsSh + " > " + outputTmp;
	cout << inputSh << endl;	

	if(FILE *f = fopen(outputTmp.c_str(), "r"))
	{
		cout << "File " << outputTmp << " found. " << endl;

	} else {

		// Execute the bash script to find out the snapshot IDs. These are usually just the snapshot numbers, 
		// but might change sometimes if there is a "hole" in between.
		cout << inputSh << endl;
		system(inputSh.c_str());
	}

	ifstream fileIn(outputTmp);
	
	// Read the catalog IDs generated by the catalog	
	while (getline(fileIn, lineIn))
	{
		strSnaps[nCat - iS -1] = lineIn.c_str(); 
		numSnaps[nCat - iS -1] = stoi(lineIn.c_str()); 
		iS++;
	}

#ifdef CLEAN_TMP
	cleanTmp = "rm " + outputTmp;
	system(cleanTmp.c_str());
#endif
};


void IOSettings::FindCatZ()
{	
	int iZ = 0;
	string outputSh;
	string inputSh;
	string optionsSh;
	string outputTmp;
	string cleanTmp;
	string lineIn;

	optionsSh = pathInput + " " + catFormat;
	outputTmp = thisPath + tmpZOut;
	inputSh = thisPath + findZsh + " " + optionsSh + " > " + outputTmp;
	cout << inputSh << endl;	

	if(FILE *f = fopen(outputTmp.c_str(), "r"))
	{
		cout << "File " << outputTmp << " found. " << endl;

	} else {
	
		// Execute the bash script and find out the redshifts of the snapshot files.
		// TODO this assumes AHF format! Other formats might not dump the z value in the output file
		cout << inputSh << endl;
		system(inputSh.c_str());
	}

	ifstream fileIn(outputTmp);
		
	// Read the redshifts generated by the catalog
	while (getline(fileIn, lineIn))
	{
		const char *lineRead = lineIn.c_str();
		float thisZ = 0.0, thisA = 0.0;

		sscanf(lineRead, "%f", &thisZ);
		thisA = 1.0 / (1.0 + thisZ) ;

		redShift[nCat - iZ - 1] = thisZ;
		aFactors[nCat - iZ - 1] = thisA;

		//cout << nCat-iZ-1 << ", z = " << redShift[nCat - iZ -1] << ", a=" << aFactors[nCat - iZ -1]<< endl;
		iZ++;
	}
	
#ifdef CLEAN_TMP
	// Remove temporary files
	cleanTmp = "rm " + outputTmp;
	system(cleanTmp.c_str());
#endif
};


void IOSettings::FindCatN()
{	
	string outputSh;
	string inputSh;
	string optionsSh;
	string outputTmp;
	string lineIn;
	string cleanTmp;

	optionsSh = pathInput + " " + catFormat;
	outputTmp = thisPath + tmpNOut;
	inputSh = thisPath + findNsh + " " + optionsSh + " > " + outputTmp;
	cout << inputSh << endl;

	if(FILE *f = fopen(outputTmp.c_str(), "r"))
	{
		cout << "File " << outputTmp << " found. " << endl;
	} else {

		system(inputSh.c_str());
	}

		ifstream fileIn(outputTmp);
		
	// Read the number of catalogs generated by the script
	while (getline(fileIn, lineIn))
	{
		const char *lineRead = lineIn.c_str();
		sscanf(lineRead, "%d", &nCat);
	}

#ifdef CLEAN_TMP	
	// Remove temporary files
	cleanTmp = "rm " + outputTmp;
	system(cleanTmp.c_str());
#endif
};


void IOSettings::Init()
{
	// Use only one task to read the files
	if (locTask == 0)
		FindCatN();

	// Once the catalog number has been found, communicate it to all tasks
	MPI_Bcast(&nCat, 1, MPI_INT, 0, MPI_COMM_WORLD);

	// Allocate memory for the catalog names, numbers, redshifts and a factors
	redShift.resize(nCat);
	aFactors.resize(nCat);
	strSnaps.resize(nCat);
	numSnaps.resize(nCat);

	// Now read the catalog names on the master task, broadcast everything later
	if (locTask == 0)
	{
		cout << "Found " << nCat << " redshifts in total." << endl;

		FindCatID();
		FindCatZ();
	}

	MPI_Bcast(&redShift[0], nCat, MPI_FLOAT, 0, MPI_COMM_WORLD);
	MPI_Bcast(&aFactors[0], nCat, MPI_FLOAT, 0, MPI_COMM_WORLD);
	MPI_Bcast(&numSnaps[0], nCat, MPI_INT, 0, MPI_COMM_WORLD);

	// Convert integerts to snapshot strings on each task, it is easier than MPI_Bcast all those chars
	if (locTask != 0)
	{
		// The snapshot format is _XXX so we assume 4 char. BEWARE! Other formats might not be compatible
		char strBuff[4];

		for (int i = 0; i < nCat; i++)
		{
			sprintf(strBuff, "%03d", numSnaps[i]); 
			strSnaps[i] = strBuff;
		}
	}

};


void IOSettings::DistributeFilesAmongTasks(void)
{
	char charCpu[5], charZ[8];
	string strZ;

	// TODO This function should optimize the halo distribution es. giving each task a slab of haloes, which 
	// would also make the FFTW operation much faster, if planning to implement a purely PM grid to compute 
	// the gravitational force at each step

	nFilesOnTask = 1;		//FIXME for the moment we do 1 file 1 task 

	haloFiles.resize(nFilesOnTask);

	for (int i = 0; i < nFilesOnTask; i++)
	{
		haloFiles[i].resize(nCat);
		sprintf(charCpu, "%04d", locTask);	// TODO this is just a temporary assignment

		for (int j = 0; j < nCat; j++)
		{
			sprintf(charZ, "%.3f", redShift[j]);	
			haloFiles[i][j] = pathInput + haloPrefix + strSnaps[j] + "." + charCpu + ".z" + charZ + "." + haloSuffix;

			ifstream fExists(haloFiles[i][j]);
				
			if (fExists.fail())
				cout << "WARNING: on task =" << locTask << " " << haloFiles[i][j] << " not found." << endl;

		}
	}
};


// Particle sizes have already been allocated in the ReadHalos() routines, do a safety check for the size
void IOSettings::ReadParticles(void)
{
	// TODO use read(buffer,size) to read quickly blocks of particles all at the same time 
	string strUrlPart = pathInput + urlTestFilePart;	// FIXME : this is only a test url for the moment
	const char *urlPart = strUrlPart.c_str();
	unsigned int iLocParts = 0, totLocParts = 0, iLine = 0, nPartHalo = 0, nFileHalos = 0;		
	unsigned long long int locHaloID;
	string lineIn;

	iLocHalos = 0;
	ifstream fileIn(urlPart);
		
	if (!fileIn.good())
		cout << "File: " << urlPart << " not found on task=" << locTask << endl;
	else 
	        cout << "Task=" << locTask << " is reading " << nLocParts << " particles from file: " << urlPart << endl;
	
	while (getline(fileIn, lineIn))
	{
		const char *lineRead = lineIn.c_str();		

		if (iLine == 0)
		{
	                sscanf(lineRead, "%d", &nFileHalos);
	
			if (nFileHalos != nLocHalos && iLine == 0)
			{
				cout << "WARNING on task=" << locTask << " expected: " << nLocHalos << " found: " <<  nFileHalos << endl;
				iLine++;
			} else {
				cout << "Particle file contains " << nLocHalos << " halos." << endl; 
				iLine++;
			}

		} else if (iLine == 1) {

	                sscanf(lineRead, "%u %llu", &nPartHalo, &locHaloID);
			iLine++;

		} else {

			locParts[iLocHalos][iLocParts].ReadLineAHF(lineRead);
			totLocParts++;
			iLocParts++;

			if (iLocParts == locHalos[iLocHalos].nPart)
			{
				iLocParts = 0;
				iLocHalos++;
				iLine = 1;	// Reset some indicators
			}
		} // else iLine not 0 or 1
	} // end while


};
 

/* Using AHF by default */
void IOSettings::ReadHalos()
{
	string strUrlHalo = pathInput + urlTestFileHalo;	// FIXME : this is only a test url for the moment
	const char *urlHalo = strUrlHalo.c_str();
	const char *lineHead = "#";
	string lineIn;

	int nPartHalo = 0;
	iLocHalos = 0; 
	
	nLocHalos = NumLines(urlHalo);	
	
	locParts.resize(nLocHalos); 
	locHalos.resize(nLocHalos); 

	locPartsSize = 0;	// This will be increased while reading the file
	locHalosSize = sizeHalo * nLocHalos;

	ifstream fileIn(urlHalo);
	
	if (!fileIn.good())
		cout << "File: " << urlHalo << " not found on task=" << locTask << endl;
	else 
	        cout << "Task=" << locTask << " is reading " << nLocHalos << " halos from file: " << urlHalo << endl;

	while (getline(fileIn, lineIn))
	{
		const char *lineRead = lineIn.c_str();		
	
		if (lineRead[0] != lineHead[0])
		{
			locHalos[iLocHalos].ReadLineAHF(lineRead);
			nPartHalo = locHalos[iLocHalos].nPart;
			locParts[iLocHalos].resize(nPartHalo);
			locPartsSize += nPartHalo * sizePart;
			nLocParts += nPartHalo; 

			// Assign halo to its nearest grid point
			GlobalGrid.AssignToGrid(locHalos[iLocHalos].X, iLocHalos);

			iLocHalos++;
		}
	}

	fileIn.close();

	cout << "On task=" << locTask << " " << locPartsSize/1024/1024 << " MB pt and " << locHalosSize/1024/1024 << " MB hl " << endl; 
	cout << "NHalos: " << locHalos.size() << " on task=" << locTask << endl;
};

   
void IOSettings::WriteTrees()
{

};

